// Production-ready Prisma schema for LifeNavigator Financial SaaS
// Supports free tier (manual + documents) and paid tier (+ integrations)

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

generator client {
  provider = "prisma-client-js"
}

// ==================== AUTH & USER MANAGEMENT ====================

model User {
  id                    String                 @id @default(cuid())
  email                 String                 @unique
  emailVerified         DateTime?
  password              String?
  name                  String?
  image                 String?
  role                  UserRole               @default(USER)
  subscriptionTier      SubscriptionTier       @default(FREE)
  subscriptionStatus    SubscriptionStatus     @default(ACTIVE)
  subscriptionExpiry    DateTime?
  isPilotMember         Boolean                @default(false)
  pilotDiscount         Float?                 // 0.5 for 50% lifetime discount
  referralCode          String?                @unique
  referredBy            String?
  referredByUser        User?                  @relation("Referrals", fields: [referredBy], references: [referralCode])
  referrals             User[]                 @relation("Referrals")
  isDemoAccount         Boolean                @default(false)
  onboardingCompleted   Boolean                @default(false)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt

  // Relations
  accounts              Account[]
  sessions              Session[]
  financialAccounts     FinancialAccount[]
  transactions          Transaction[]
  documents             Document[]
  budgets               Budget[]
  goals                 Goal[]
  insights              Insight[]
  plaidItems            PlaidItem[]
  stripeCustomer        StripeCustomer?
  verificationTokens    VerificationToken[]
  passwordResetTokens   PasswordResetToken[]
  mfaSettings           MfaSetting?
  securityAuditLogs     SecurityAuditLog[]
  notifications         Notification[]
  waitlistEntry         WaitlistEntry?
  dataExports           DataExport[]
  categories            Category[]
  merchants             Merchant[]
  recurringTransactions RecurringTransaction[]
  financialSnapshots    FinancialSnapshot[]

  @@index([email])
  @@index([subscriptionTier])
  @@index([referralCode])
}

enum UserRole {
  USER
  ADMIN
  DEMO
}

enum SubscriptionTier {
  FREE
  PRO          // $20/mo
  AI_AGENT     // $99/mo
  FAMILY       // $35/mo
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  PAUSED
  TRIALING
}

// NextAuth models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  id         String   @id @default(cuid())
  identifier String
  token      String   @unique
  expires    DateTime
  userId     String?
  user       User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([identifier, token])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

// ==================== FINANCIAL ACCOUNTS ====================

model FinancialAccount {
  id                 String               @id @default(cuid())
  userId             String
  user               User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Account details
  accountName        String
  accountType        AccountType
  institutionName    String
  institutionId      String?              // For Plaid connections
  accountNumber      String?              // Last 4 digits only, encrypted
  routingNumber      String?              // Encrypted
  
  // Balances
  currentBalance     Float
  availableBalance   Float?
  creditLimit        Float?               // For credit cards
  minimumPayment     Float?               // For credit cards/loans
  apr                Float?               // Annual percentage rate
  
  // Integration source
  dataSource         DataSource           @default(MANUAL)
  plaidItemId        String?
  plaidItem          PlaidItem?           @relation(fields: [plaidItemId], references: [id])
  plaidAccountId     String?              // Plaid's account ID
  
  // Status
  isActive           Boolean              @default(true)
  isHidden           Boolean              @default(false)
  lastSynced         DateTime?
  syncError          String?
  
  // Metadata
  currency           String               @default("USD")
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  
  // Relations
  transactions       Transaction[]
  manualAccount      ManualAccount?
  budgets            Budget[]
  goals              Goal[]
  recurringTransactions RecurringTransaction[]

  @@unique([plaidAccountId, plaidItemId])
  @@index([userId])
  @@index([accountType])
  @@index([dataSource])
}

enum AccountType {
  CHECKING
  SAVINGS
  CREDIT_CARD
  INVESTMENT
  LOAN
  MORTGAGE
  OTHER
}

enum DataSource {
  MANUAL
  PLAID
  DOCUMENT
  CSV_IMPORT
}

// ==================== TRANSACTIONS ====================

model Transaction {
  id                    String               @id @default(cuid())
  userId                String
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId             String
  account               FinancialAccount     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  // Transaction details
  transactionDate       DateTime
  postDate              DateTime?
  amount                Float
  description           String
  originalDescription   String?              // Raw description from source
  
  // Categorization
  categoryId            String?
  category              Category?            @relation(fields: [categoryId], references: [id])
  subcategory           String?
  merchantId            String?
  merchant              Merchant?            @relation(fields: [merchantId], references: [id])
  
  // Source info
  dataSource            DataSource           @default(MANUAL)
  plaidTransactionId    String?              @unique
  documentId            String?
  document              Document?            @relation(fields: [documentId], references: [id])
  
  // Additional fields
  isPending             Boolean              @default(false)
  isRecurring           Boolean              @default(false)
  recurringTransactionId String?
  recurringTransaction  RecurringTransaction? @relation(fields: [recurringTransactionId], references: [id])
  notes                 String?
  tags                  String[]             @default([])
  
  // Location data (if available)
  location              String?
  latitude              Float?
  longitude             Float?
  
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt

  @@index([userId])
  @@index([accountId])
  @@index([transactionDate])
  @@index([categoryId])
  @@index([merchantId])
  @@index([dataSource])
}

model Category {
  id              String          @id @default(cuid())
  userId          String?         // null for system categories
  user            User?           @relation(fields: [userId], references: [id], onDelete: Cascade)
  name            String
  parentId        String?
  parent          Category?       @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children        Category[]      @relation("CategoryHierarchy")
  icon            String?
  color           String?
  isSystem        Boolean         @default(false)
  transactions    Transaction[]
  budgets         Budget[]
  
  @@unique([userId, name])
  @@index([userId])
}

model Merchant {
  id              String          @id @default(cuid())
  userId          String?         // null for system merchants
  user            User?           @relation(fields: [userId], references: [id], onDelete: Cascade)
  name            String
  displayName     String?
  categoryId      String?
  logo            String?
  website         String?
  isVerified      Boolean         @default(false)
  transactions    Transaction[]
  
  @@unique([userId, name])
  @@index([userId])
}

// ==================== PLAID INTEGRATION ====================

model PlaidItem {
  id                  String              @id @default(cuid())
  userId              String
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Plaid credentials (encrypted)
  accessToken         String              @db.Text // Encrypted
  itemId              String              @unique
  institutionId       String
  institutionName     String
  
  // Status
  isActive            Boolean             @default(true)
  lastSuccessfulSync  DateTime?
  lastSyncError       String?
  webhookUrl          String?
  
  // Consent
  consentExpiresAt    DateTime?
  
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  
  // Relations
  accounts            FinancialAccount[]
  webhookEvents       PlaidWebhookEvent[]

  @@index([userId])
}

model PlaidWebhookEvent {
  id              String      @id @default(cuid())
  plaidItemId     String
  plaidItem       PlaidItem   @relation(fields: [plaidItemId], references: [id], onDelete: Cascade)
  webhookType     String
  webhookCode     String
  itemId          String
  error           Json?
  newTransactions Int?
  removedTransactions String[]
  processed       Boolean     @default(false)
  createdAt       DateTime    @default(now())

  @@index([plaidItemId])
  @@index([processed])
}

// ==================== DOCUMENT MANAGEMENT ====================

model Document {
  id                 String             @id @default(cuid())
  userId             String
  user               User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // File info
  fileName           String
  fileType           String
  fileSize           Int
  fileUrl            String             // Secure URL from storage provider
  storageKey         String             @unique // Storage provider reference
  
  // Document details
  documentType       DocumentType
  uploadedAt         DateTime           @default(now())
  
  // Processing status
  processingStatus   ProcessingStatus   @default(PENDING)
  processedAt        DateTime?
  processingError    String?
  
  // Extracted data
  extractedData      Json?              // Structured data from OCR/parsing
  confidence         Float?             // OCR confidence score
  pageCount          Int?
  
  // Relations
  transactions       Transaction[]      // Transactions created from this document
  parsedAccounts     Json?              // Accounts found in document
  
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  @@index([userId])
  @@index([documentType])
  @@index([processingStatus])
}

enum DocumentType {
  BANK_STATEMENT
  CREDIT_CARD_STATEMENT
  INVESTMENT_STATEMENT
  TAX_DOCUMENT
  RECEIPT
  INVOICE
  OTHER
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  MANUAL_REVIEW
}

// ==================== MANUAL DATA ENTRY ====================

model ManualAccount {
  id                String           @id @default(cuid())
  accountId         String           @unique
  account           FinancialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  // Additional manual fields
  accountHolder     String?
  openedDate        DateTime?
  notes             String?
  
  // For loans/mortgages
  originalBalance   Float?
  interestRate      Float?
  termMonths        Int?
  monthlyPayment    Float?
  
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
}

// ==================== BUDGETS & GOALS ====================

model Budget {
  id              String           @id @default(cuid())
  userId          String
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name            String
  amount          Float
  period          BudgetPeriod
  categoryId      String?
  category        Category?        @relation(fields: [categoryId], references: [id])
  accountId       String?
  account         FinancialAccount? @relation(fields: [accountId], references: [id])
  
  startDate       DateTime
  endDate         DateTime?
  isActive        Boolean          @default(true)
  
  // Tracking
  currentSpent    Float            @default(0)
  lastCalculated  DateTime?
  
  // Alerts
  alertEnabled    Boolean          @default(true)
  alertThreshold  Float            @default(0.8) // Alert at 80% by default
  
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([userId])
  @@index([categoryId])
}

enum BudgetPeriod {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

model Goal {
  id              String           @id @default(cuid())
  userId          String
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name            String
  description     String?
  targetAmount    Float
  currentAmount   Float            @default(0)
  targetDate      DateTime
  
  goalType        GoalType
  priority        GoalPriority     @default(MEDIUM)
  
  // Linked accounts for tracking
  accountId       String?
  account         FinancialAccount? @relation(fields: [accountId], references: [id])
  
  // Progress tracking
  isCompleted     Boolean          @default(false)
  completedAt     DateTime?
  lastCalculated  DateTime?
  
  // Milestones
  milestones      Json?            // Array of milestone objects
  
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([userId])
}

enum GoalType {
  SAVINGS
  DEBT_PAYOFF
  INVESTMENT
  PURCHASE
  EMERGENCY_FUND
  RETIREMENT
  OTHER
}

enum GoalPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// ==================== INSIGHTS & ANALYTICS ====================

model Insight {
  id              String          @id @default(cuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type            InsightType
  category        String
  title           String
  description     String          @db.Text
  
  // AI-generated content
  aiGenerated     Boolean         @default(false)
  confidence      Float?          // AI confidence score
  
  // Data reference
  relatedData     Json?           // References to accounts, transactions, etc.
  
  // User interaction
  isRead          Boolean         @default(false)
  isDismissed     Boolean         @default(false)
  isActionable    Boolean         @default(true)
  actionUrl       String?
  
  // Validity
  validFrom       DateTime        @default(now())
  validUntil      DateTime?
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([userId])
  @@index([type])
  @@index([isRead])
}

enum InsightType {
  SPENDING_ALERT
  SAVINGS_OPPORTUNITY
  BILL_REMINDER
  GOAL_PROGRESS
  UNUSUAL_ACTIVITY
  OPTIMIZATION
  MARKET_UPDATE
  TAX_TIP
}

model FinancialSnapshot {
  id              String          @id @default(cuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  snapshotDate    DateTime
  
  // Aggregated data
  totalAssets     Float
  totalLiabilities Float
  netWorth        Float
  monthlyIncome   Float
  monthlyExpenses Float
  savingsRate     Float
  
  // Account breakdowns
  accountBalances Json            // Detailed balance by account
  categorySpending Json           // Spending by category
  
  createdAt       DateTime        @default(now())

  @@unique([userId, snapshotDate])
  @@index([userId])
  @@index([snapshotDate])
}

// ==================== RECURRING TRANSACTIONS ====================

model RecurringTransaction {
  id              String              @id @default(cuid())
  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId       String
  account         FinancialAccount    @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  // Pattern details
  merchantName    String
  amount          Float
  amountVariance  Float?              // Allowed variance in amount
  frequency       RecurringFrequency
  dayOfMonth      Int?                // For monthly
  dayOfWeek       Int?                // For weekly
  
  // Next occurrence
  nextDate        DateTime
  isActive        Boolean             @default(true)
  
  // Detection
  confidence      Float               // How confident we are this is recurring
  lastDetected    DateTime
  occurrenceCount Int                 @default(0)
  
  transactions    Transaction[]
  
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([userId])
  @@index([accountId])
}

enum RecurringFrequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
  ANNUALLY
}

// ==================== SUBSCRIPTION & BILLING ====================

model StripeCustomer {
  id                    String   @id @default(cuid())
  userId                String   @unique
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stripeCustomerId      String   @unique
  
  // Subscription info
  subscriptionId        String?
  priceId               String?
  currentPeriodEnd      DateTime?
  cancelAtPeriodEnd     Boolean  @default(false)
  
  // Payment method
  defaultPaymentMethod  String?
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

// ==================== WAITLIST & REFERRALS ====================

model WaitlistEntry {
  id              String          @id @default(cuid())
  email           String          @unique
  userId          String?         @unique
  user            User?           @relation(fields: [userId], references: [id])
  
  position        Int             @unique @default(autoincrement())
  referralCode    String          @unique
  referredBy      String?
  referralCount   Int             @default(0)
  
  // Conversion tracking
  signedUpAt      DateTime?
  convertedAt     DateTime?
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([referralCode])
}

// ==================== NOTIFICATIONS ====================

model Notification {
  id              String              @id @default(cuid())
  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type            NotificationType
  title           String
  message         String
  data            Json?               // Additional context
  
  isRead          Boolean             @default(false)
  readAt          DateTime?
  
  // Delivery
  channels        String[]            // ["email", "push", "in_app"]
  emailSent       Boolean             @default(false)
  pushSent        Boolean             @default(false)
  
  createdAt       DateTime            @default(now())

  @@index([userId])
  @@index([isRead])
}

enum NotificationType {
  ACCOUNT_SYNC
  TRANSACTION_ALERT
  BUDGET_ALERT
  GOAL_PROGRESS
  BILL_REMINDER
  SECURITY_ALERT
  SYSTEM_UPDATE
  SUBSCRIPTION_UPDATE
}

// ==================== DATA EXPORT ====================

model DataExport {
  id              String          @id @default(cuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  format          ExportFormat
  status          ExportStatus    @default(PENDING)
  fileUrl         String?
  expiresAt       DateTime?
  
  // What was exported
  includeAccounts Boolean         @default(true)
  includeTransactions Boolean     @default(true)
  includeDocuments Boolean        @default(false)
  dateFrom        DateTime?
  dateTo          DateTime?
  
  requestedAt     DateTime        @default(now())
  completedAt     DateTime?
  error           String?

  @@index([userId])
}

enum ExportFormat {
  CSV
  JSON
  PDF
}

enum ExportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  EXPIRED
}

// ==================== SECURITY & AUDIT ====================

model SecurityAuditLog {
  id              String          @id @default(cuid())
  userId          String?
  user            User?           @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  event           String
  eventType       AuditEventType
  ipAddress       String?
  userAgent       String?
  metadata        Json?
  
  createdAt       DateTime        @default(now())

  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
}

enum AuditEventType {
  LOGIN_SUCCESS
  LOGIN_FAILED
  LOGOUT
  PASSWORD_CHANGED
  MFA_ENABLED
  MFA_DISABLED
  ACCOUNT_LOCKED
  DATA_EXPORT
  ACCOUNT_DELETED
  PERMISSION_CHANGED
  INTEGRATION_CONNECTED
  INTEGRATION_DISCONNECTED
}

model MfaSetting {
  id              String          @id @default(cuid())
  userId          String          @unique
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  enabled         Boolean         @default(false)
  method          MfaMethod       @default(TOTP)
  secret          String?         @db.Text // Encrypted
  backupCodes     String[]        // Encrypted
  
  lastUsedAt      DateTime?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

enum MfaMethod {
  TOTP
  SMS
  EMAIL
}